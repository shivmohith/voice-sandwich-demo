"""WebSocket-based transport for conversing with an external AI voice agent.

Connects to an external agent's WebSocket endpoint, sends audio generated by
the pipecat bot (acting as a simulated user), and receives the agent's audio
responses back into the pipeline.

Protocol (external agent):
  - Send: raw PCM16 bytes (16-bit, mono) as binary WebSocket frames
  - Receive: JSON text messages with event types including tts_chunk (base64 audio)

Usage:
    transport = WSAgentTransport(
        uri="ws://localhost:8000/ws",
        params=TransportParams(audio_in_enabled=True, audio_out_enabled=True),
        max_turns=5,
    )
"""

import asyncio
import base64
import json
import os
import wave
from datetime import datetime
from typing import Optional

import websockets
from loguru import logger

from pipecat.frames.frames import (
    BotStoppedSpeakingFrame,
    EndFrame,
    Frame,
    InputAudioRawFrame,
    OutputAudioRawFrame,
    StartFrame,
    UserStartedSpeakingFrame,
    UserStoppedSpeakingFrame,
)
from pipecat.processors.frame_processor import FrameDirection, FrameProcessor
from pipecat.transports.base_input import BaseInputTransport
from pipecat.transports.base_output import BaseOutputTransport
from pipecat.transports.base_transport import BaseTransport, TransportParams


# Audio format the external agent's TTS produces
AGENT_TTS_SAMPLE_RATE = 24000
AGENT_TTS_NUM_CHANNELS = 1


class WSAgentInputTransport(BaseInputTransport):
    """Receives audio from the external agent via WebSocket and pushes it into the pipeline."""

    def __init__(
        self,
        params: TransportParams,
        agent_done_event: asyncio.Event,
        done_event: asyncio.Event,
        max_turns: int,
        save_output: bool = False,
        output_dir: str = "simulation_audio",
        **kwargs,
    ):
        super().__init__(params, **kwargs)
        self._agent_done_event = agent_done_event
        self._done_event = done_event
        self._max_turns = max_turns
        self._save_output = save_output
        self._output_dir = output_dir
        self._ws: Optional[websockets.WebSocketClientProtocol] = None
        self._ws_ready = asyncio.Event()
        self._receive_task: Optional[asyncio.Task] = None
        self._agent_speaking = False
        self._turn_count = 0
        self._current_audio_chunks: list[bytes] = []

    def set_ws(self, ws: websockets.WebSocketClientProtocol):
        self._ws = ws
        self._ws_ready.set()

    async def start(self, frame: StartFrame):
        await super().start(frame)
        await self.set_transport_ready(frame)
        self._receive_task = asyncio.create_task(self._receive_loop())

    async def cleanup(self):
        await super().cleanup()
        if self._save_output and self._current_audio_chunks:
            self._save_turn_audio()
        if self._receive_task:
            self._receive_task.cancel()
            try:
                await self._receive_task
            except asyncio.CancelledError:
                pass

    def _save_turn_audio(self):
        import os

        os.makedirs(self._output_dir, exist_ok=True)
        filepath = os.path.join(
            self._output_dir, f"turn_{self._turn_count:03d}_agent.wav"
        )

        audio_data = b"".join(self._current_audio_chunks)
        self._current_audio_chunks.clear()

        with wave.open(filepath, "wb") as wf:
            wf.setnchannels(AGENT_TTS_NUM_CHANNELS)
            wf.setsampwidth(2)
            wf.setframerate(AGENT_TTS_SAMPLE_RATE)
            wf.writeframes(audio_data)

        logger.info(f"Saved agent audio: {filepath}")

    async def _receive_loop(self):
        """Read JSON events from the external agent's WebSocket."""
        try:
            await self._ws_ready.wait()
            async for raw_message in self._ws:
                if self._done_event.is_set():
                    break

                try:
                    event = json.loads(raw_message)
                except (json.JSONDecodeError, TypeError):
                    logger.warning(f"Non-JSON message received: {raw_message!r:.100}")
                    continue

                event_type = event.get("type")

                if event_type == "tts_chunk":
                    audio_b64 = event.get("audio", "")
                    if not audio_b64:
                        continue
                    audio_bytes = base64.b64decode(audio_b64)

                    if not self._agent_speaking:
                        self._agent_speaking = True
                        await self.push_frame(UserStartedSpeakingFrame())

                    if self._save_output:
                        self._current_audio_chunks.append(audio_bytes)

                    frame = InputAudioRawFrame(
                        audio=audio_bytes,
                        sample_rate=AGENT_TTS_SAMPLE_RATE,
                        num_channels=AGENT_TTS_NUM_CHANNELS,
                    )
                    await self.push_audio_frame(frame)

                elif event_type == "agent_end":
                    if self._agent_speaking:
                        self._agent_speaking = False
                        await self.push_frame(UserStoppedSpeakingFrame())

                    if self._current_audio_chunks:
                        self._turn_count += 1
                        logger.info(
                            f"[Agent turn {self._turn_count}/{self._max_turns}] "
                            "External agent finished speaking"
                        )

                        if self._save_output:
                            self._save_turn_audio()

                        if self._turn_count >= self._max_turns:
                            logger.info(
                                f"Max turns ({self._max_turns}) reached, ending conversation"
                            )
                            self._done_event.set()
                            return
                    else:
                        logger.debug("Agent end with no audio, not counting as turn")

                    self._agent_done_event.set()

                elif event_type == "stt_output":
                    logger.info(
                        f"[Agent STT] {event.get('transcript', '')}"
                    )

                elif event_type == "agent_chunk":
                    pass  # Streaming text, logged at agent_end via stt_output

        except websockets.exceptions.ConnectionClosed:
            logger.info("WebSocket connection closed by external agent")
            self._done_event.set()
        except asyncio.CancelledError:
            logger.info("Receive loop cancelled")
        except Exception:
            logger.exception("Error in WebSocket receive loop")
            self._done_event.set()


class WSAgentOutputTransport(BaseOutputTransport):
    """Sends the simulated user's audio to the external agent via WebSocket."""

    def __init__(
        self,
        params: TransportParams,
        bot_done_event: asyncio.Event,
        done_event: asyncio.Event,
        save_output: bool = False,
        output_dir: str = "simulation_audio",
        **kwargs,
    ):
        super().__init__(params, **kwargs)
        self._bot_done_event = bot_done_event
        self._done_event = done_event
        self._save_output = save_output
        self._output_dir = output_dir
        self._ws: Optional[websockets.WebSocketClientProtocol] = None
        self._turn_count = 0
        self._current_audio_chunks: list[bytes] = []
        self._sample_rate = 0

    def set_ws(self, ws: websockets.WebSocketClientProtocol):
        self._ws = ws

    async def start(self, frame: StartFrame):
        await super().start(frame)
        self._sample_rate = self._params.audio_out_sample_rate or frame.audio_out_sample_rate
        await self.set_transport_ready(frame)

    async def push_frame(self, frame: Frame, direction: FrameDirection = FrameDirection.DOWNSTREAM):
        if isinstance(frame, BotStoppedSpeakingFrame) and direction == FrameDirection.DOWNSTREAM:
            logger.debug("Simulated user stopped speaking — signaling input transport")
            if self._save_output and self._current_audio_chunks:
                self._save_turn_audio()
            self._bot_done_event.set()
        await super().push_frame(frame, direction)

    async def write_audio_frame(self, frame: OutputAudioRawFrame) -> bool:
        """Send audio to the external agent over WebSocket."""
        if self._ws is None or self._done_event.is_set():
            return False
        try:
            await self._ws.send(frame.audio)
            if self._save_output:
                self._current_audio_chunks.append(frame.audio)
            return True
        except websockets.exceptions.ConnectionClosed:
            logger.warning("Cannot send audio — WebSocket closed")
            return False

    def _save_turn_audio(self):
        import os

        os.makedirs(self._output_dir, exist_ok=True)
        self._turn_count += 1
        filepath = os.path.join(self._output_dir, f"turn_{self._turn_count:03d}_simulated_user.wav")

        audio_data = b"".join(self._current_audio_chunks)
        self._current_audio_chunks.clear()

        with wave.open(filepath, "wb") as wf:
            wf.setnchannels(1)
            wf.setsampwidth(2)
            wf.setframerate(self._sample_rate)
            wf.writeframes(audio_data)

        logger.info(f"Saved simulated user audio: {filepath}")

    async def cleanup(self):
        await super().cleanup()
        if self._save_output and self._current_audio_chunks:
            self._save_turn_audio()


class WSAgentTransport(BaseTransport):
    """Transport that connects to an external voice agent over WebSocket.

    The pipecat bot acts as a simulated user: its TTS output is sent to the
    external agent, and the agent's audio responses are fed back into the pipeline.

    Args:
        uri: WebSocket URI of the external agent (e.g., "ws://localhost:8000/ws").
        params: Transport params (set audio_in_enabled=True, audio_out_enabled=True).
        max_turns: Maximum number of conversation turns before stopping (max 5).
        save_audio: If True, saves the simulated user's audio to WAV files.
        output_dir: Directory to save audio files.
    """

    def __init__(
        self,
        uri: str,
        params: TransportParams,
        max_turns: int = 5,
        save_audio: bool = False,
        output_dir: str = "simulation_audio",
    ):
        super().__init__()
        self._uri = uri
        self._params = params
        self._max_turns = min(max_turns, 5)
        self._save_audio = save_audio
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self._output_dir = os.path.join(output_dir, timestamp)

        # Coordination events
        self._agent_done_event = asyncio.Event()
        self._bot_done_event = asyncio.Event()
        self._done_event = asyncio.Event()

        self._ws: Optional[websockets.WebSocketClientProtocol] = None
        self._input: Optional[WSAgentInputTransport] = None
        self._output: Optional[WSAgentOutputTransport] = None

        self._register_event_handler("on_client_connected")
        self._register_event_handler("on_client_disconnected")

    def input(self) -> FrameProcessor:
        if not self._input:
            self._input = WSAgentInputTransport(
                params=self._params,
                agent_done_event=self._agent_done_event,
                done_event=self._done_event,
                max_turns=self._max_turns,
                save_output=self._save_audio,
                output_dir=self._output_dir,
            )
        return self._input

    def output(self) -> FrameProcessor:
        if not self._output:
            self._output = WSAgentOutputTransport(
                params=self._params,
                bot_done_event=self._bot_done_event,
                done_event=self._done_event,
                save_output=self._save_audio,
                output_dir=self._output_dir,
            )
        return self._output

    async def run(self):
        """Connect to the external agent and run until conversation completes.

        Note: call close() after the pipeline has fully stopped to tear down
        the WebSocket connection cleanly.
        """
        logger.info(f"Connecting to external agent at {self._uri}")

        try:
            self._ws = await websockets.connect(self._uri, open_timeout=10)
            logger.info("Connected to external agent")

            # Share the WebSocket connection with input/output transports
            if self._input:
                self._input.set_ws(self._ws)
            if self._output:
                self._output.set_ws(self._ws)

            await self._call_event_handler("on_client_connected", self._ws)

            # Wait until max turns reached or connection closed
            await self._done_event.wait()
            logger.info("Conversation complete")

            # Fire disconnect handler — this cancels the pipeline via bot.py
            await self._call_event_handler("on_client_disconnected", None)
        except Exception:
            logger.exception("Error connecting to external agent")
            await self._call_event_handler("on_client_disconnected", None)

    async def close(self):
        """Close the WebSocket connection. Call after the pipeline has stopped."""
        if self._ws:
            await self._ws.close()
            self._ws = None
            logger.info("WebSocket closed")
